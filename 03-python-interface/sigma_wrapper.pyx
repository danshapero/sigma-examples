
import numpy as np
cimport numpy as np


cdef extern:
    void fe_solve(  int num_nodes,
                    int num_edges,
                    int num_triangles,
                    double *x, double *y,
                    int *edges,
                    int *triangles,
                    int *boundary,
                    double *f,
                    double *u   )

np.import_array()


# ---------------------------------------------------------------------------- #
def read_mesh(filename):                                                       #
# ---------------------------------------------------------------------------- #
    """
    Read in a mesh generated by the program Triangle

    Parameters:
    ==========
    filename: the stem of the mesh file, e.g. if the mesh files are
              mesh.1.node, mesh.1.ele, etc then filename = "mesh.1"

    Returns:
    =======
    x, y: the coordinates of the mesh points
    boundary: the boundary marker of each node
    edges: list of all edges of the triangulation
    triangles: list of all triangles
    """

    cdef int num_nodes = 0
    cdef int num_edges = 0
    cdef int num_triangles = 0
    cdef int i = 0
    cdef int _ = 0

    # Read in the nodes of the triangulation
    fid = open(filename + ".node", "r")
    num_nodes, _, _, _ = map(int, fid.readline().split())

    cdef double[:] x = np.zeros(num_nodes, dtype=np.double)
    cdef double[:] y = np.zeros(num_nodes, dtype=np.double)
    cdef int[:] boundary = np.zeros(num_nodes, dtype=np.int32)
    for i in range(num_nodes):
        line = fid.readline().split()
        x[i] = float(line[1])
        y[i] = float(line[2])
        boundary[i] = int(line[3])

    fid.close()

    # Read in the edges
    fid = open(filename + ".edge", "r")
    num_edges, _ = map(int, fid.readline().split())

    cdef int[:,:] edges = np.zeros((num_edges,2), dtype=np.int32)
    cdef int[:] edge_boundary = np.zeros(num_edges, dtype=np.int32)
    for i in range(num_edges):
        line = fid.readline().split()[1:]
        edges[i, 0] = int(line[0])
        edges[i, 1] = int(line[1])
        edge_boundary[i] = int(line[2])

    fid.close()

    # Read in the triangles
    fid = open(filename + ".ele", "r")
    num_triangles, _, _ = map(int, fid.readline().split())

    cdef int[:,:] triangles = np.zeros((num_triangles,3), dtype=np.int32)
    for i in range(num_triangles):
        line = fid.readline().split()[1:]
        triangles[i, 0] = int(line[0])
        triangles[i, 1] = int(line[1])
        triangles[i, 2] = int(line[2])

    fid.close()

    X = np.asarray(x)
    Y = np.asarray(y)
    Boundary = np.asarray(boundary)
    Edges = np.asarray(edges)
    Triangles = np.asarray(triangles)

    return X, Y, Boundary, Edges, Triangles



# ---------------------------------------------------------------------------- #
def poisson_solve(  np.ndarray x,
                    np.ndarray y,
                    np.ndarray boundary,
                    np.ndarray edges,
                    np.ndarray triangles,
                    np.ndarray f):
# ---------------------------------------------------------------------------- #
    """
    Solve the Poisson problem on a triangular mesh with a given right-hand side

    Parameters:
    ==========
    x, y: the coordinates of the mesh points
    boundary: boundary marker of each node; 0 if inside, >= 1 if node
    edges, triangles: lists of edges & triangles of the triangulation
    f: vector of nodal values for the right-hand side vector

    Returns:
    =======
    u: solution to Poisson problem
    """

    cdef int num_nodes = 0
    cdef int num_edges = 0
    cdef int num_triangles = 0

    # Get typed memory views of all the input numpy arrays
    cdef double[:] X = x
    cdef double[:] Y = y
    cdef int[:] Boundary = boundary
    cdef int[:,:] Edges = edges
    cdef int[:,:] Triangles = triangles
    cdef double[:] F = f

    # Get the mesh size
    num_nodes = np.shape(X)[0]
    num_edges = np.shape(Edges)[0]
    num_triangles = np.shape(Triangles)[0]

    # Call a Fortran procedure to solve the PDE
    cdef double[:] u = np.zeros(num_nodes, dtype=np.double)
    fe_solve(num_nodes, num_edges, num_triangles,
            &X[0], &Y[0], &Edges[0,0], &Triangles[0,0], &Boundary[0],
            &F[0], &u[0])

    # Turn the typed memory view of the solution `u` into a numpy array
    U = np.asarray(u)

    return U

