
import numpy as np
cimport numpy as np


cdef extern from "fe_solver.h":
    void fe_solve(  int num_nodes,
                    int num_edges,
                    int num_triangles,
                    double *x, double *y,
                    int *edges,
                    int *triangles,
                    int *boundary,
                    double *u   )

np.import_array()

# ---------------------------------------------------------------------------- #
def poisson_solve(filename):                                                   #
# ---------------------------------------------------------------------------- #
    """
    Read in a mesh generated by the program Triangle, then solve the Poisson
    problem with a random RHS on that mesh.

    Parameters:
    ==========
    filename: the stem of the mesh file, e.g. if the mesh files are
              mesh.1.node, mesh.1.ele, ... then the correct filename
              is "mesh.1".

    Returns:
    =======
    x, y: the coordinates of the mesh points
    boundary: the boundary marker of each node
    edges: list of all edges of the triangulation
    triangles: list of all triangles
    u: solution to Poisson problem
    """

    cdef int num_nodes = 0
    cdef int num_edges = 0
    cdef int num_triangles = 0
    cdef int i = 0
    cdef int _ = 0

    # Read in the nodes of the triangulation
    fid = open(filename + ".node", "r")
    num_nodes, _, _, _ = map(int, fid.readline().split())

    cdef double[:] x = np.zeros(num_nodes, dtype=np.double)
    cdef double[:] y = np.zeros(num_nodes, dtype=np.double)
    cdef int[:] boundary = np.zeros(num_nodes, dtype=np.int32)
    for i in range(num_nodes):
        line = fid.readline().split()
        x[i] = float(line[1])
        y[i] = float(line[2])
        boundary[i] = int(line[3])

    fid.close()

    # Read in the edges
    fid = open(filename + ".edge", "r")
    num_edges, _ = map(int, fid.readline().split())

    cdef int[:,:] edges = np.zeros((num_edges,2), dtype=np.int32)
    cdef int[:] edge_boundary = np.zeros(num_edges, dtype=np.int32)
    for i in range(num_edges):
        line = fid.readline().split()[1:]
        edges[i, 0] = int(line[0])
        edges[i, 1] = int(line[1])
        edge_boundary[i] = int(line[2])

    fid.close()

    # Read in the triangles
    fid = open(filename + ".ele", "r")
    num_triangles, _, _ = map(int, fid.readline().split())

    cdef int[:,:] triangles = np.zeros((num_triangles,3), dtype=np.int32)
    for i in range(num_triangles):
        line = fid.readline().split()[1:]
        triangles[i, 0] = int(line[0])
        triangles[i, 1] = int(line[1])
        triangles[i, 2] = int(line[2])

    fid.close()

    # Call a Fortran procedure
    cdef double[:] u = np.zeros(num_nodes, dtype=np.double)

    fe_solve(num_nodes, num_edges, num_triangles,
            &x[0], &y[0], &edges[0,0], &triangles[0,0], &boundary[0], &u[0])

    X = np.asarray(x)
    Y = np.asarray(y)
    U = np.asarray(u)
    Boundary = np.asarray(boundary)
    Edges = np.asarray(edges)
    Triangles = np.asarray(triangles)

    return X, Y, Boundary, Edges, Triangles, U

